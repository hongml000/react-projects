{
  "message": "success",
  "data": {
    "title": "可爱的程序员哟，你忘掉的是这堆Java锁呢？还是这把死锁呢？",
    "content": "<img className='detail-img' src='https://upload-images.jianshu.io/upload_images/15590149-eba140f5948f857e?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp' alt=''/><p><strong>1、乐观锁</strong></p><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是<strong>在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作</strong>（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p><p>Java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，<strong>比较当前值跟传入值是否一样，一样则更新，否则失败</strong>。</p><p><strong>2、悲观锁</strong></p><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java中的悲观锁就是<strong>Synchronized</strong>，AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。</p><p><strong>3、自旋锁</strong></p><p>自旋锁原理非常简单，<strong>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</strong></p><p><strong>4、自旋锁</strong></p><p>自旋锁原理非常简单，<strong>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</strong></p>"
  }
}